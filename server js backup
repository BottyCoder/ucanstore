const express = require("express");
const bodyParser = require("body-parser");
const axios = require("axios");
const fs = require("fs");
require("dotenv").config();
const moment = require("moment-timezone");

const app = express();
const PORT = process.env.PORT || 3000;

const CLIENT_ID = process.env.HUBSPOT_CLIENT_ID;
const CLIENT_SECRET = process.env.HUBSPOT_CLIENT_SECRET;
const REDIRECT_URI = process.env.HUBSPOT_REDIRECT_URI || "https://fork-pouncing-lobe.glitch.me/oauth/callback";
const TOKEN_PATH = "./tokens.json";
const LOGS_PATH = "./logs.csv";
const HUBSPOT_API_URL = "https://api.hubapi.com";

app.use(bodyParser.json());

const logEvent = (event, details) => {
 const timestamp = moment().tz("Africa/Johannesburg").format();

  const logEntry = `${timestamp},${event},${JSON.stringify(details)}\n`;
  fs.appendFileSync(LOGS_PATH, logEntry);
  console.log(`[LOG] ${timestamp} - ${event}:`, details);
};

const getTokens = () => {
  if (fs.existsSync(TOKEN_PATH)) {
    return JSON.parse(fs.readFileSync(TOKEN_PATH));
  }
  return {};
};

const refreshAccessToken = async () => {
  let tokens = getTokens();
  if (!tokens.refresh_token) {
    throw new Error("No refresh token available");
  }

  const response = await axios.post(`${HUBSPOT_API_URL}/oauth/v1/token`, null, {
    params: {
      grant_type: "refresh_token",
      client_id: CLIENT_ID,
      client_secret: CLIENT_SECRET,
      refresh_token: tokens.refresh_token,
    },
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
  });

  const newTokens = {
    access_token: response.data.access_token,
    refresh_token: response.data.refresh_token,
    expires_in: response.data.expires_in,
    obtained_at: new Date().getTime(),
  };

  fs.writeFileSync(TOKEN_PATH, JSON.stringify(newTokens, null, 2));
  return newTokens.access_token;
};

const getValidAccessToken = async () => {
  let tokens = getTokens();
  if (!tokens.access_token || (tokens.obtained_at + tokens.expires_in * 1000) < Date.now()) {
    return await refreshAccessToken();
  }
  return tokens.access_token;
};

app.get("/oauth/start", (req, res) => {
  const authUrl = `https://app.hubspot.com/oauth/authorize?client_id=${CLIENT_ID}&redirect_uri=${encodeURIComponent(
    REDIRECT_URI
  )}&scope=conversations.custom_channels.read%20conversations.custom_channels.write%20conversations.read%20conversations.write%20crm.objects.contacts.read%20crm.objects.contacts.write%20tickets%20oauth&response_type=code`;

  console.log("OAuth Start URL:", authUrl);
  res.redirect(authUrl);
});

app.get("/oauth/callback", async (req, res) => {
  const authCode = req.query.code;
  if (!authCode) return res.status(400).send("Authorization code not found.");

  try {
    const response = await axios.post("https://api.hubapi.com/oauth/v1/token", null, {
      params: {
        grant_type: "authorization_code",
        client_id: CLIENT_ID,
        client_secret: CLIENT_SECRET,
        redirect_uri: REDIRECT_URI,
        code: authCode,
      },
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
    });

    const tokens = {
      access_token: response.data.access_token,
      refresh_token: response.data.refresh_token,
      expires_in: response.data.expires_in,
      obtained_at: new Date().getTime(),
    };

    fs.writeFileSync(TOKEN_PATH, JSON.stringify(tokens, null, 2));
    logEvent("OAuthCallbackSuccess", tokens);
    console.log("[SUCCESS] OAuth Authentication Successful! Tokens stored.");
    res.send("OAuth Authentication Successful! Tokens stored.");
  } catch (error) {
    logEvent("OAuthCallbackError", error.response?.data || error.message);
    res.status(500).send("Error obtaining access token.");
  }
});

// ✅ Lookup Contact by First & Last Name
app.post("/lookup-contact", async (req, res) => {
  try {
    const { firstname, lastname } = req.body;
    if (!firstname || !lastname) return res.status(400).json({ error: "First and last name required." });
    logEvent("LookupContactRequest", { firstname, lastname });

    const accessToken = await getValidAccessToken();
    const response = await axios.post(
      "https://api.hubapi.com/crm/v3/objects/contacts/search",
      {
        filterGroups: [
          {
            filters: [
              { propertyName: "firstname", operator: "EQ", value: firstname },
              { propertyName: "lastname", operator: "EQ", value: lastname }
            ]
          }
        ]
      },
      {
        headers: { Authorization: `Bearer ${accessToken}`, "Content-Type": "application/json" }
      }
    );

    const contact = response.data.results[0] || null;
    logEvent("LookupContactResponse", contact);
    res.json(contact);
  } catch (error) {
    logEvent("LookupContactError", error.response?.data || error.message);
    res.status(500).json({ error: "Failed to lookup contact." });
  }
});

// ✅ Fetch Ticket for Contact
app.get("/fetch-ticket", async (req, res) => {
  try {
    const { contact_id } = req.query;
    if (!contact_id) return res.status(400).json({ error: "Contact ID required." });
    logEvent("FetchTicketRequest", { contact_id });

    const accessToken = await getValidAccessToken();
    const response = await axios.get(`https://api.hubapi.com/crm/v3/associations/contacts/${contact_id}/tickets`, {
      headers: { Authorization: `Bearer ${accessToken}` }
    });

    const ticket = response.data.results[0] || null;
    logEvent("FetchTicketResponse", ticket);
    res.json(ticket);
  } catch (error) {
    logEvent("FetchTicketError", error.response?.data || error.message);
    res.status(500).json({ error: "Failed to fetch ticket." });
  }
});

// ✅ Fetch Notes for a Ticket
app.get("/fetch-notes", async (req, res) => {
  try {
    const { ticket_id } = req.query;
    if (!ticket_id) return res.status(400).json({ error: "Ticket ID required." });
    logEvent("FetchNotesRequest", { ticket_id });

    const accessToken = await getValidAccessToken();
    const response = await axios.get(`https://api.hubapi.com/crm/v3/associations/tickets/${ticket_id}/notes`, {
      headers: { Authorization: `Bearer ${accessToken}` }
    });

    logEvent("FetchNotesResponse", response.data);
    res.json(response.data);
  } catch (error) {
    logEvent("FetchNotesError", error.response?.data || error.message);
    res.status(500).json({ error: "Failed to fetch notes." });
  }
});



// ✅ Sync Contact with HubSpot
app.post("/hubspot-sync-contact", async (req, res) => {
  try {
    const { phone, email } = req.body;
    if (!phone && !email) return res.status(400).json({ error: "Phone or Email is required" });
    logEvent("SyncContactRequest", { phone, email });

    const accessToken = await getValidAccessToken();
    let contactId = null;

    if (phone) {
      try {
        const phoneSearch = await axios.post(`${HUBSPOT_API_URL}/crm/v3/objects/contacts/search`, {
          filterGroups: [{ filters: [{ propertyName: "phone", operator: "EQ", value: phone }] }]
        }, { headers: { Authorization: `Bearer ${accessToken}`, "Content-Type": "application/json" } });

        if (phoneSearch.data.total > 0) {
          contactId = phoneSearch.data.results[0].id;
        }
      } catch (error) {
        logEvent("HubSpotPhoneSearchError", error.response?.data || error.message);
      }
    }

    if (!contactId && email) {
      try {
        const emailSearch = await axios.post(`${HUBSPOT_API_URL}/crm/v3/objects/contacts/search`, {
          filterGroups: [{ filters: [{ propertyName: "email", operator: "EQ", value: email }] }]
        }, { headers: { Authorization: `Bearer ${accessToken}`, "Content-Type": "application/json" } });

        if (emailSearch.data.total > 0) {
          contactId = emailSearch.data.results[0].id;
        }
      } catch (error) {
        logEvent("HubSpotEmailSearchError", error.response?.data || error.message);
      }
    }

    res.json({ success: true, contactId });
  } catch (error) {
    logEvent("SyncContactError", error.response?.data || error.message);
    res.status(500).json({ error: "Failed to sync contact" });
  }
});

/// Helper function to convert timestamps to SAST
const convertToSAST = (timestamp) => {
  return moment(timestamp).tz("Africa/Johannesburg").format();
};

// ✅ Automate Full Process: Respond to All Open Tickets and Store in Supabase
// ✅ Automate Full Process: Respond to All Open Tickets and Store in Supabase
app.post("/automate-process", async (req, res) => {
  try {
    const { reply } = req.body;
    if (!reply) return res.status(400).json({ error: "Reply text is required." });
    logEvent("AutomateProcessStart", { reply });

    const accessToken = await refreshAccessToken();
    
    const ticketResponse = await axios.post(
      `${HUBSPOT_API_URL}/crm/v3/objects/tickets/search`,
      {
        filterGroups: [{
          filters: [{ propertyName: "hs_pipeline_stage", operator: "EQ", value: "1" }]
        }]
      },
      { headers: { Authorization: `Bearer ${accessToken}`, "Content-Type": "application/json" } }
    );

    const tickets = ticketResponse.data.results;
    if (!tickets || tickets.length === 0) {
      logEvent("NoOpenTicketsFound", {});
      return res.json({ success: false, message: "No open tickets found." });
    }

    logEvent("OpenTicketsFound", { tickets });

    for (const ticket of tickets) {
      logEvent("ProcessingTicket", { ticketId: ticket.id });
      
      let contactId = ticket.properties.hs_contact_id || null;
      
      if (!contactId) {
        logEvent("FetchingContactForTicket", { ticketId: ticket.id });
        try {
          const associationResponse = await axios.get(
            `${HUBSPOT_API_URL}/crm/v3/associations/tickets/${ticket.id}/contacts`,
            { headers: { Authorization: `Bearer ${accessToken}` } }
          );
          if (associationResponse.data.results.length > 0) {
            contactId = associationResponse.data.results[0].id;
            logEvent("FoundContactForTicket", { ticketId: ticket.id, contactId });
          } else {
            logEvent("NoContactForTicket", { ticketId: ticket.id });
          }
        } catch (error) {
          logEvent("ErrorFetchingContact", {
            ticketId: ticket.id,
            status: error.response?.status,
            message: error.response?.data || error.message
          });
        }
      }

      if (!contactId) {
        logEvent("SkippingTicketNoContact", { ticketId: ticket.id });
        continue;
      }
    }

    res.json({ success: true, ticketsProcessed: tickets.length });
  } catch (error) {
    logEvent("AutomateProcessError", {
      status: error.response?.status,
      message: error.response?.data || error.message,
      headers: error.response?.headers,
      requestBody: error.config?.data
    });

    res.status(500).json({ error: "Automation process failed." });
  }
});




app.listen(PORT, () => console.log(`Server running on port ${PORT}`));
